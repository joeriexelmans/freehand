<!DOCTYPE html>
<html>
<head>
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    .controls {
      border-style: solid;
      border-width: 1px;
      border-color: black;
    }
    .controls > * {
      margin: 10px;
      user-select: none;
    }
  </style>
</head>
<body>

<svg id="svg" style="position: absolute; top: 0px; left: 0px; height: 100%; width:100%; touch-action: none">
  <g id="panning"/>
</svg>

<div class="controls" style="position: absolute; top: 0px; left: 0px; z-index: 100; background-color: white;">

<span>
  <input id="undo" type="button" value="undo" disabled />
  <input id="redo" type="button" value="redo" disabled />
</span>

<label>
  <input id="ctrl-pressure" type="checkbox" checked>
  pressure sensitive
</label>
<label>
  <input id="ctrl-strokewidth" type="number" value="2" style="width:40px" min="1">
  stroke width
</label>
<label>
  <input id="ctrl-tool-pen" name="tool" value="pen" type="radio" checked>
  pen
</label>
<label>
  <input id="ctrl-tool-select" name="tool" value="select" type="radio">
  select
</label>
<label>
  <input id="ctrl-tool-pan" name="tool" value="pan" type="radio">
  pan
</label>

<label>
  <span id="mem-usage">0</span>
  bytes
</label>
</div>

<script>
  const MAXPATHLENGTH = 200;
  const rootSvg = document.getElementById("svg");
  const panningG = document.getElementById("panning");
  const memUsageElement = document.getElementById("mem-usage");
  const undoButton = document.getElementById("undo");
  const redoButton = document.getElementById("redo");

  // global state

  // for every pointer, we keep the state (drawing, selecting, ...)
  const pointerId2Stroke = new Map();

  // everything that has been drawn on the canvas
  let paths = [];

  // viewport pan
  let panX = 0;
  let panY = 0;

  // current selection
  let selection = null;

  let undoStack = [];
  let redoStack = [];

  undoButton.addEventListener("click", e => {
    const toUndo = undoStack.pop();
    if (toUndo.type === "move-select") {
      const {selection, dX, dY} = toUndo;
      moveSelection(selection, -dX, -dY);
    }
    else if (toUndo.type === "stroke") {
      for (const {element} of toUndo.subpaths) {
        panningG.removeChild(element);
      }
      paths.pop(); // safe to assume that path to undo is last in this list.
    }
    else if (toUndo.type === "select") {
      const {selection: s, prevSelection, element} = toUndo;
      if (s !== null) {
        panningG.removeChild(s.rect);
      }
      if (prevSelection !== null) {
        panningG.appendChild(prevSelection.rect);
      }
      selection = prevSelection;
    }
    pushRedo(toUndo);
    if (undoStack.length === 0) {
      undoButton.setAttribute("disabled", "true");
    }
    computeMemUsage();
  });

  redoButton.addEventListener("click", e => {
    const toRedo = redoStack.pop();
    if (toRedo.type === "move-select") {
      const {selection, dX, dY} = toRedo;
      moveSelection(selection, dX, dY);
    }
    else if (toRedo.type === "stroke") {
      for (const {element} of toRedo.subpaths) {
        panningG.appendChild(element);
      }
      paths.push({subpaths: toRedo.subpaths});
    }
    else if (toRedo.type === "select") {
      const {selection: s, prevSelection, element} = toRedo;
      if (s !== null) {
        panningG.appendChild(s.rect);
      }
      if (prevSelection !== null) {
        panningG.removeChild(prevSelection.rect);
      }
      selection = s;
    }
    pushUndo(toRedo);
    if (redoStack.length === 0) {
      redoButton.setAttribute("disabled", "true");
    }
    computeMemUsage();
  })

  function pushUndo(what) {
    undoStack.push(what);
    undoButton.removeAttribute("disabled");
  }

  function pushRedo(what) {
    redoStack.push(what);
    redoButton.removeAttribute("disabled");
  }

  function clearRedo(what) {
    redoStack = [];
    redoButton.setAttribute("disabled", "true");
  }

  function moveSelection(selection, dX, dY) {
    for (const subpaths of selection.paths) {
      for (const {element, points} of subpaths) {
        for (let i=0; i<points.length; i+=2) {
          points[i]   += dX;
          points[i+1] += dY;
        }
        element.setAttributeNS(null, "d", pointsToD(points));
      }
    }
    selection.bbox.minX += dX;
    selection.bbox.minY += dY;
    selection.bbox.maxX += dX;
    selection.bbox.maxY += dY;
    setSelectionRectToBBox(selection.rect, selection.bbox);
  }

  // pure (but modifies 'rect' in-place)
  function setSelectionRectToBBox(rect, bbox) {
    rect.setAttributeNS(null, "x", bbox.minX);
    rect.setAttributeNS(null, "y", bbox.minY);
    rect.setAttributeNS(null, "width", bbox.maxX - bbox.minX);
    rect.setAttributeNS(null, "height", bbox.maxY - bbox.minY);
  }

  function pan(dx, dy) {
    panX += dx;
    panY += dy;
    panningG.setAttributeNS(null, "transform", `translate(${panX}, ${panY})`);
  }

  let strokeWidth = 2;
  document.getElementById("ctrl-strokewidth").addEventListener("change", e => {
    strokeWidth = +e.target.value;
  });

  let pressureSensitive = true;
  document.getElementById("ctrl-pressure").addEventListener("change", e => {
    pressureSensitive = e.target.checked;
  });

  let mode = "pen";
  ["ctrl-tool-pen", "ctrl-tool-select", "ctrl-tool-pan"].forEach(tool => {
    document.getElementById(tool).addEventListener("change", e => {
      if (e.target.checked) {
         mode = e.target.value;
      }
    });
  });

  // only a very rough approximation to know the 'ball park' numbers
  function computeMemUsage() {
    let pointCount = 0;
    for (const {subpaths} of paths) {
      for (const {points} of subpaths) {
        pointCount += points.length;
      }
    }
    const memUsage = pointCount * 8; // 8 bytes per number
    memUsageElement.innerText = memUsage.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }

  function startPath(e, continuePath) {
    const virtualX = e.clientX - panX;
    const virtualY = e.clientY - panY;
    const element = document.createElementNS("http://www.w3.org/2000/svg", "path");
    element.setAttributeNS(null, "d", `M ${virtualX} ${virtualY}`);
    element.setAttributeNS(null, "stroke", "black");
    element.setAttributeNS(null, "stroke-width", (pressureSensitive ? (e.pressure || 0.1) : 0.7)*strokeWidth);
    element.setAttributeNS(null, "fill", "none");
    // add path to its own <g> so we can move it efficiently later
    let subpaths;
    if (continuePath) {
      subpaths = continuePath.subpaths;
    } else {
      subpaths = [];
      paths.push({subpaths}); // add to global state
    }
    panningG.appendChild(element);
    subpaths.push({element, points: [virtualX, virtualY]});
    pointerId2Stroke.set(e.pointerId, {type: "stroke", subpaths});
  }

  function startSelection(e) {
    const virtualX = e.clientX - panX;
    const virtualY = e.clientY - panY;
    if (selection) {
      // pointer is in bounding box?
      if (virtualX >= selection.bbox.minX && virtualX <= selection.bbox.maxX
       && virtualY >= selection.bbox.minY && virtualY <= selection.bbox.maxY) {
        pointerId2Stroke.set(e.pointerId, {
          type: "move-select",
          selection,
          startX: virtualX,
          startY: virtualY,
          lastX: virtualX,
          lastY: virtualY,
        });
        return;
      }
      // panningG.removeChild(selection.rect);
      // selection = null;
    }
    const element = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    element.setAttributeNS(null, "x", virtualX);
    element.setAttributeNS(null, "y", virtualY);
    element.setAttributeNS(null, "fill", "none");
    element.setAttributeNS(null, "stroke", "blue");
    element.setAttributeNS(null, "stroke-width", "1");
    element.setAttributeNS(null, "stroke-dasharray", "5 8");
    panningG.appendChild(element);
    pointerId2Stroke.set(e.pointerId, {type: "select", element, startX: virtualX, startY: virtualY});
  }

  function startPan(e) {
    pointerId2Stroke.set(e.pointerId, {type: "pan", lastX: e.clientX, lastY: e.clientY});
  }

  // pure
  function euclideanDistance(x1, y1, x2, y2) {
    const distX = x1 - x2;
    const distY = y1 - y2;
    return Math.sqrt(distX*distX + distY*distY);
  }

  // pure
  function pointsToD(points) {
    return points.reduce((acc, current) => acc + ` ${current}`, "M");
  }

  function onPointerMove(e) {
    const found = pointerId2Stroke.get(e.pointerId);
    if (found !== undefined) {
      const virtualX = e.clientX - panX;
      const virtualY = e.clientY - panY;
      if (found.type === "stroke") {
        if (e.pressure > 0.1) {
          const {subpaths} = found;
          const {element, points} = subpaths[subpaths.length-1];
          if (points.length >= MAXPATHLENGTH) {
            // performance tweak:
            // split stroke up into several paths
            // start a new path that 'connects' to the old path
            startPath({
              clientX: points[points.length-2] + panX,
              clientY: points[points.length-1] + panY,
              pointerId: e.pointerId,
              pressure: e.pressure,
            }, found);
            return onPointerMove(e);
          }
          if (pressureSensitive) {
            // restart path if pressure changed sufficiently
            const pathStrokeWidth = +element.getAttributeNS(null, "stroke-width");
            if (Math.abs(e.pressure-pathStrokeWidth/strokeWidth)>0.1) {
              startPath({
                clientX: points[points.length-2] + panX,
                clientY: points[points.length-1] + panY,
                pointerId: e.pointerId,
                pressure: e.pressure,
              }, found);
              return onPointerMove(e);
            }
          }

          // // performance tweak: remove points that don't matter much
          // // To do this, we look at the last three points.
          // // If the `middle' point is roughly on the line between the oldest and newest point, then we remove the middle point.
          // if (points.length >= 4) {
          //   const distPreviousTwoPoints = euclideanDistance(points[points.length-4],points[points.length-3],points[points.length-2],points[points.length-1]);
          //   const distLastTwoPoints = euclideanDistance(points[points.length-2], points[points.length-1], virtualX, virtualY);
          //   const distTwoPointsAgo = euclideanDistance(points[points.length-4],points[points.length-3], virtualX, virtualY);
          //   // last three points will be on a single line if the sum of the distances from middle point to outer points is roughly equal to the distance between the outer points.

          //   const difference = (distPreviousTwoPoints+distLastTwoPoints-distTwoPointsAgo)/distTwoPointsAgo;
          //   if (difference < 0.01 && distTwoPointsAgo < 20) {
          //     // remove middle point:
          //     points.pop();
          //     points.pop();
          //   }
          // }
          points.push(virtualX, virtualY);
          const d = pointsToD(points);
          element.setAttributeNS(null, "d", d);
        }
      }
      else if (found.type === "select") {
        // update selection rectangle
        const {element, startX, startY} = found;
        const x = Math.min(startX, virtualX);
        const y = Math.min(startY, virtualY);
        const w = Math.abs(virtualX - startX);
        const h = Math.abs(virtualY - startY);
        element.setAttributeNS(null, "x", x);
        element.setAttributeNS(null, "y", y);
        element.setAttributeNS(null, "width", w);
        element.setAttributeNS(null, "height", h);
      }
      else if (found.type === "move-select") {
        const {lastX, lastY, selection} = found;
        dX = virtualX - lastX;
        dY = virtualY - lastY;
        moveSelection(selection, dX, dY);
        found.lastX = virtualX;
        found.lastY = virtualY;
      }
      else if (found.type === "pan") {
        const {lastX, lastY} = found;
        pan(e.clientX - lastX, e.clientY - lastY);
        found.lastX = e.clientX;
        found.lastY = e.clientY;
      }
    }
  }

  function onPointerUp(e) {
    const found = pointerId2Stroke.get(e.pointerId);
    if (found !== undefined) {
      if (found.type === "select") {
        const {element, startX, startY} = found;
        const endX = e.clientX - panX;
        const endY = e.clientY - panY;
        const minX = Math.min(startX, endX);
        const minY = Math.min(startY, endY);
        const maxX = Math.max(startX, endX);
        const maxY = Math.max(startY, endY);
        const selectedStrokes = [];
        for (const {subpaths} of paths) {
          const inSelection = subpaths.every(({element, points}) => {
            for (let i=0; i<points.length; i+=2) {
              const pointX = points[i];
              const pointY = points[i+1];
              if (!( pointX >= minX && pointX <= maxX
                  && pointY >= minY && pointY <= maxY)) {
                return false;
              }
            }
            return true;
          });
          if (inSelection) {
            selectedStrokes.push(subpaths);
          }
        }
        const prevSelection = selection;
        if (selection !== null) {
          panningG.removeChild(selection.rect);
        }
        if (selectedStrokes.length > 0) {
          // reuse selection rectangle to visualize selection state
          const bbox = computeSelectionBBox(selectedStrokes);
          setSelectionRectToBBox(element, bbox);
          // set global state
          selection = {
            paths: selectedStrokes,
            rect: element,
            bbox,
          };
        }
        else {
          panningG.removeChild(element);
          // set global state
          selection = null;
        }
        console.log({type: "select", selection, prevSelection});
        pushUndo({type: "select", selection, prevSelection});
      }
      else if (found.type === "stroke") {
        pushUndo(found);
        clearRedo();
      }
      else if (found.type === "move-select") {
        pushUndo({
          type: "move-select",
          dX: found.lastX-found.startX,
          dY: found.lastY-found.startY,
          selection: found.selection
        });
        clearRedo();
      }
    }
    pointerId2Stroke.delete(e.pointerId);
    computeMemUsage();
  }

  // pure
  function computeSelectionBBox(selection) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (const stroke of selection) {
      for (const {element, points} of stroke) {
        for (let i=0; i<points.length; i+=2) {
          const pointX = points[i];
          const pointY = points[i+1];
          minX = Math.min(minX, pointX);
          minY = Math.min(minY, pointY);
          maxX = Math.max(maxX, pointX);
          maxY = Math.max(maxY, pointY);
        }
      }
    }
    return {minX, minY, maxX, maxY};
  }

  rootSvg.addEventListener("pointerdown", e => {
    if (mode === "pen") {
      startPath(e);
    }
    else if (mode === "select") {
      startSelection(e);
    }
    else if (mode === "pan") {
      startPan(e);
    }
  });

  rootSvg.addEventListener("pointermove", onPointerMove);
  rootSvg.addEventListener("pointerup", onPointerUp);

  rootSvg.addEventListener("touchstart", e => {
    // console.log(e);
  });
  rootSvg.addEventListener("touchmove", e => {
    // console.log(e);
  });

  document.addEventListener("keydown", e => {
    if (e.key === "Delete") {
      if (selection) {
        // delete selected paths
        for (const stroke of selection.paths) {
          for (const {element} of stroke) {
            panningG.removeChild(element);
          }
        }
        paths = paths.filter(stroke => !selection.paths.includes(stroke));
        panningG.removeChild(selection.rect);
        selection = null;
        computeMemUsage();
      }
    }
  })
</script>
</body>
</html>